# 2 Data

```{r, echo = FALSE, message = FALSE}
source(here::here("scripts/setup.R"))
```
__TO DO's__

* Wrangling/cleaning
* Sources - TBS
* Description - In progress
* Wrangling/cleaning - In progress
* Spotting mistakes and missing data (could be part of EDA too) - TBD
* Listing anomalies and outliers (could be part of EDA too) - TBD


## 2.1 Raw Datasets

The datasets encompass:

- **Vehicle Registrations**: Detailed regional breakdowns showing vehicle type, fuel type, and numbers across years.
- **Google Trends**: Time-series data showcasing the interest in electric vehicles and environmental topics over time.
- **Oil Prices**: Time-series data indicating Brent oil price fluctuations over the years.
- **Demographics**: Indicators like population growth, immigration, emigration, gender statistics, and more, which can influence vehicle adoption patterns.

```{r}
# Reading the data
vehicle_data_2005_2008 <- read.csv("../data/road_vehicle_CH_2005-2008.csv")
vehicle_data_2009_2022 <- read.csv("../data/road_vehicle_CH_2009-2022.csv")
google_trends_data1 <- read.csv("../data/googletrends_auto-elettrica_2005-2022.csv")
google_trends_data2 <- read.csv("../data/googletrends_elektro-auto_2005-2022.csv")
google_trends_data3 <- read.csv("../data/googletrends_elektrofahrzeug_2005-2022.csv")
google_trends_data4 <- read.csv("../data/googletrends_elektromobil_2005-2022.csv")
google_trends_data5 <- read.csv("../data/googletrends_eletric-car_2005-2022.csv")
google_trends_data6 <- read.csv("../data/googletrends_EV_2005-2022.csv")
google_trends_data7 <- read.csv("../data/googletrends_vehicule-electrique_2005-2022.csv")
google_trends_data8 <- read.csv("../data/googletrends_voiture-electrique_2005-2022.csv")
oil_prices_data <- read.csv("../data/BrentOilPrices.csv")
demographic_data <- read.csv("../data/demographic.csv")
charging_station <- read.csv("../data/charging_station.csv")
france_v <- read_excel("../data/parc_vp_france_2022.xlsx",sheet = 2)
```
For this phase of the project, our approach involves presenting diverse datasets in a table form. To achieve this, we used the kable function from the kableExtra package, resulting in a table that displays each variable along with its corresponding definition.

### 2.1.1 Swiss Vehicle Registration Dataset

* Description
This data set explains the new registrations of road vehicles by vehicle group, canton, vehicle type, fuel, month and year in Switzerland. This data set is essential to evaluate the EVs’ evolution within our chosen location. 

```{r}
# Create a tibble with variable descriptions
variable_table_vehicle <- tibble(
  Variables = c("Canton", "Vehicle group / type", "Fuel", "Month", "2009-2022"),
  Meaning = c(
    "The region in Switzerland.",
    "Type or group of the vehicle.",
    "Type of fuel used by the vehicle.",
    "The month of the data.",
    "Number of vehicles for each respective year. Each with it's own column"
  )
)

# Display the table using kableExtra
variable_table_vehicle %>%
  kbl() %>%
  kable_styling(position = "center")
```


* Source
 https://www.bfs.admin.ch/bfs/en/home/statistics/catalogues-databases/data.assetdetail.24105892.html


### 2.1.2 Oil price Dataset

* description
This data set explains the evolution of the price of brent oil over time. From this data set, we will be able to obtain precious information to compute our linear regressions concerning oil price and EVs adoptions.   

```{r}
# Create a tibble with variable descriptions
variable_table <- tibble(
  Variables = c("Date", "Price"),
  Meaning = c(
    "The date when the price was recorded. In a day-month-year format.",
    "The price of Brent Oil on the given date."
  )
)

# Display the table using kableExtra
variable_table %>%
  kbl() %>%
  kable_styling(position = "center")
```


* source
https://www.kaggle.com/datasets/mabusalah/brent-oil-prices 

### 2.1.3 Swiss Demographics Dataset

* description
While this dataset contains a substantial amount of information, only a fraction of it will be pertinent to our research. It explains the evolution of the Swiss population over time through variables given below.

```{r}
# Create a tibble with variable descriptions
variable_table <- tibble(
  Variables = c(
    "Year", "Citizenship (category)", "Sex", "Age", "Population on 1 January", 
    "Live birth", "Death", "Natural change", 
    "Immigration incl. change of population type", "Emigration", 
    "Net migration incl. change of population type", 
    "Change of population type", "Acquisition of Swiss citizenship", 
    "Gender change in the civil register (entry)", 
    "Gender change in the civil register (exit)", "Statistical adjustment", 
    "Population on 31 December", "Population change"
  ),
  Meaning = c(
    "The year of the demographic data.",
    "The categorization of the citizenship status.",
    "Gender category.",
    "Age category.",
    "Population count at the beginning of the year.",
    "Number of births in the year.",
    "Number of deaths in the year.",
    "Change in the population due to births and deaths.",
    "Number of immigrants, including change of population type.",
    "Number of emigrations.",
    "Net migration count, including change of population type.",
    "Change in the categorization of the population.",
    "Number of individuals who acquired Swiss citizenship.",
    "Number of gender changes registered (entry).",
    "Number of gender changes registered (exit).",
    "Adjustments made to the data for accuracy.",
    "Population count at the end of the year.",
    "Change in population over the year."
  )
)

# Display the table using kableExtra
variable_table %>%
  kbl() %>%
  kable_styling(position = "center")
```

* source
https://www.bfs.admin.ch/bfs/en/home/statistics/catalogues-databases/data.assetdetail.26645079.html 

### 2.1.4 Google trend data
* Description
This Data set shows the evolution of Google trends on 8 different terms. We chose these terms in all 3 different main Swiss national languages (French, Italian and German) to make sure we get the most accurate data possible. Those variables will help us highlight potential tendencies/trends.  

```{r}
# Create a tibble with variable descriptions
variable_table_google_trend <- tibble(
  Variables = c("Month", 
                "Search Term: Voiture électrique", 
                "Search Term: Véhicule électrique", 
                "Search Term: EV", 
                "Search Term: Electric Car", 
                "Search Term: Elektromobil", 
                "Search Term: Elektrofahrzeug", 
                "Search Term: Elektro Auto", 
                "Search Term: Auto Elettrica"),
  Meaning = c(
    "The month of the data",
    "Google Trends data for 'Voiture électrique: (Suisse)'",
    "Google Trends data for 'Véhicule électrique: (Suisse)'",
    "Google Trends data for 'EV: (Suisse)'",
    "Google Trends data for 'Electric car: (Suisse)'",
    "Google Trends data for 'Elektromobil: (Suisse)'",
    "Google Trends data for 'Elektrofahrzeug: (Suisse)'",
    "Google Trends data for 'Elektro Auto: (Suisse)'",
    "Google Trends data for 'Auto Elettrica: (Suisse)'"
  )
)
# Display the table using kableExtra
variable_table_google_trend %>%
  kbl() %>%
  kable_styling(position = "center")
```

* source
https://trends.google.fr/trends/explore?q=voiture%20%C3%A9lectrique&date=now%201-d&geo=CH&hl=fr  
https://trends.google.fr/trends/explore?date=now%201-d&geo=CH&q=v%C3%A9hicule%20%C3%A9lectrique&hl=fr  
https://trends.google.fr/trends/explore?date=now%201-d&geo=CH&q=EV&hl=fr  
https://trends.google.fr/trends/explore?date=now%201-d&geo=CH&q=Electric%20car&hl=fr  
https://trends.google.fr/trends/explore?date=now%201-d&geo=CH&q=Elektromobil&hl=fr  
https://trends.google.fr/trends/explore?date=now%201-d&geo=CH&q=Elektrofahrzeug&hl=fr  
https://trends.google.fr/trends/explore?date=now%201-d&geo=CH&q=Elektro%20Auto&hl=fr
https://trends.google.fr/trends/explore?date=now%201-d&geo=CH&q=Auto%20elettrica&hl=fr  

### 2.1.5 French vehicle registration data

* description
We decided to add this data set to help us compare with another country. Indeed, France is an adjacent country which might imply potential similarities in the outcome. This data set is made of variables such as the Date of the French vehicle registration or whether it is from a professional user or not.  The information we are interested in concern the number of registered vehicles in the country by propulsion method over time.

```{r}
# Create a tibble with variable descriptions
variable_table <- tibble(
  Variables = c("Date", "Ensemble des voitures particulieres", "Professionnel", "Particulier", "Crit'Air"),
  Meaning = c(
    "The date, in year format, in which the observations are registered",
    "The sum of vehicle in every groups",
    "Category 'Professional' of vehicle",
    "Category 'Passenger Car' of vehicle",
    "Categorizes vehicles by emissions with from best to worst classes"
  )
)

# Display the table using kableExtra
variable_table %>%
  kbl() %>%
  kable_styling(position = "center")
```

* source
https://www.statistiques.developpement-durable.gouv.fr/donnees-sur-le-parc-de-vehicules-en-circulation-au-1er-janvier-2022

### 2.1.6 Chargin Stations

* description
This data set is meant to determine the number of charging stations per canton, per charging power, per month, per plug type in Switzerland since November 2020. It is important to mention that a station can have multiple charging points. These values will help us to obtain more information about the Swiss adaption to EVs and their potential effects on EVs adoption by the Swiss population  
```{r}
# Create a tibble with variable descriptions in English
variable_table_charging <- tibble(
  Variables = c("year",
                "month",
                "stations_CH_count",
                "stations_XY_count",
                "locations_CH_count",
                "locations_XY_count",
                "plugs_CH_count",
                "plugs_XY_count",
                "chargingPower_CH_sum",
                "chargingPower_XY_sum",
                "chargingPower_CH_count",
                "chargingPower_XY_count",
                "chargingPower_10kW_count",
                "chargingPower_21kW_count",
                "chargingPower_42kW_count"),
  Meaning = c(
    "Year of the key figures collection.",
    "Month of the key figures collection. These are collected daily and published monthly.",
    "Number of available charging stations in Switzerland. A station can have multiple charging points.",
    "Number of charging stations per canton. A station can have multiple charging points. This attribute is available for all cantons, XY representing the official canton abbreviation.",
    "Number of stations in Switzerland. A station can have multiple charging points.",
    "Number of stations per canton. A station can have multiple charging points. This attribute is available for all cantons, XY representing the official canton abbreviation.",
    "Number of charging plugs in Switzerland.",
    "Number of charging plugs per plug type in Switzerland. This attribute is available for all plug types, XY corresponding to the plug type according to the Open Intercharge Protocol (OICP) version 2.2 (see below).",
    "Total maximum charging power in kilowatts of recharge stations in Switzerland. Only charging points with known power are considered (see chargingPower_CH_count).",
    "Total maximum charging power in kilowatts of recharge stations in a canton. Only charging points with known power are considered (see chargingPower_XY_count).",
    "Number of recharge stations in Switzerland with known maximum charging power and for which the total maximum charging power has been taken into account (chargingPower_CH_sum).",
    "Number of recharge stations per canton with known maximum charging power and for which the total maximum charging power has been taken into account (chargingPower_XY_sum).",
    "Number of recharge stations in Switzerland with known maximum charging power delivering a maximum charging power of 10 kW.",
    "Number of recharge stations in Switzerland with known maximum charging power ranging from over 10 kW to 21 kW.",
    "Number of recharge stations in Switzerland with known maximum charging power ranging from over 21 kW to 42 kW."
  )
)

# Display the table using kableExtra
variable_table_charging %>%
  kbl() %>%
  kable_styling(position = "center")

```

* source
https://www.bfe.admin.ch/bfe/fr/home/approvisionnement/statistiques-et-geodonnees/geoinformation/geodonnees/mobilite/bornes-de-recharge-pour-la-mobilite-electrique.html 


## 2.2 Data Wrangling
### 2.2.1 Data Wrangling : Oil clean

First when trying to format the dataset, we realized that it created thousands of NAs. After further 
exploring the data, we realized that there were 2 different date formats. First format: [DD- MMM –
YYYY], second format: [MMM DD, YYYY]. Therefore, our first date formatting did not work.
This forced us to clean both tables (one for each format), before joining them together.
Then, another issue we encountered was to present the date in a standardized form across all our 
data sets to perform time series analyses. For that, we had to change the abbreviated months names 
(i.e. Jan, Feb, etc.) into numbers.

```{r}
# Change date column into Day

# Two types of format: one format before 22.04.2020,a different format after

# 22.04.2020 is on row 8361
# Format 1: 15-Apr-2020
oil_df_1 <- oil_prices_data[0:8360,] |>
  separate(Date, into = c("Day", "Month", "Year"), sep = "-")

# Format 2 : Apr 22, 2020
oil_df_2 <- oil_prices_data[8361:nrow(oil_prices_data),] |>
  separate(Date, into = c("Month", "Day", "Year"), sep = " |, ")

# Check for NAs
print(which(rowSums(is.na(oil_df_1)) > 0))
print(which(rowSums(is.na(oil_df_2)) > 0))

# We don't need dates before 2005
oil_df_1 <- oil_df_1[4486:nrow(oil_df_1),]

# Years in same format for both
oil_df_1$Year <- paste0("20", oil_df_1$Year)

# Change the order of both dataframes
oil_df_1 <- oil_df_1 %>%
  select("Year", "Month", "Day", "Price")

oil_df_2 <- oil_df_2 %>%
  select("Year", "Month", "Day", "Price")

# Merging both dataframes together
oil_df <- rbind(oil_df_1, oil_df_2)

# We want all our data to have the same date format #YYYY-MM-DD

# First we create a df to change the current month format to numbers
months_numbers <- data.frame(
  current_month_format = c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"),
  numbers = 1:12
)

# Then we update our oil_data
oil_df <- oil_df %>%
  left_join(months_numbers, by = c("Month" = "current_month_format")) %>%
  select(Year, numbers, Day, Price) %>%
  rename(Months = numbers)

# Regroup the date in 1 column
oil_df <- oil_df %>%
  mutate(Date = as.Date(paste(Year, Months, Day, sep = "-"))) %>%
  select(Date, Price)


# Displayed clean data
reactable(oil_df,
          sortable = TRUE, 
          searchable = TRUE)
```

### 2.2.2 Data Wrangling : Google trend clean

Comprehending Google Trends information involves understanding the contextualization of the provided figures. The data is standardized.

The crucial element for effective narration lies in utilizing the normalized Trends data. This normalization indicates that when observing search interest trends over time, it is interpreted as a ratio relative to all searches conducted on all topics on Google during that specific period and location. Likewise, when assessing regional search interest for a specific topic, it is construed as the search interest for that particular topic in a given region relative to all searches on all topics on Google in that same place and time.

[Source](https://medium.com/google-news-lab/what-is-google-trends-data-and-what-does-it-mean-b48f07342ee8)

To clean and process eight Google Trends datasets related to different search terms, we created a function process_dataset() that reads each CSV file, removes date indices, excludes the first row, checks for missing values, renames columns, converts types, and standardizes the date format. Then, we iterated through each dataset, merged them based on the "Date" column, summed values for each search term per date, normalized these values between 1 and 100.

```{r}
dataset_names <- c(
  "googletrends_auto-elettrica_2005-2022.csv",
  "googletrends_elektro-auto_2005-2022.csv",
  "googletrends_elektrofahrzeug_2005-2022.csv",
  "googletrends_elektromobil_2005-2022.csv",
  "googletrends_eletric-car_2005-2022.csv",
  "googletrends_EV_2005-2022.csv",
  "googletrends_vehicule-electrique_2005-2022.csv",
  "googletrends_voiture-electrique_2005-2022.csv"
)

# Function to process each dataset
process_dataset <- function(file_path) {
  # Read the dataset
  google_trends_data <- read.csv(file_path)

  # Remove the dates from the index
  google_trends_data <- google_trends_data |> rownames_to_column(var = "Date")

  # Remove the first row using slice
  google_trends_data <- slice(google_trends_data, -1)

  # Check for NA
  cat("NA count for", file_path, ": ", sum(is.na(google_trends_data$Date)), "\n")
  cat("NA count for SearchCount in", file_path, ": ", sum(is.na(google_trends_data$Catégorie...Toutes.catégories)), "\n")

  # Rename col
  colnames(google_trends_data)[2] <- "SearchCount"

  # Convert to numeric
  google_trends_data$SearchCount <- as.numeric(google_trends_data$SearchCount)

  # Convert the column to date with the desired format
  google_trends_data$Date <- as.Date(paste(google_trends_data$Date, "01", sep = "-"))

  return(google_trends_data)
}

# Process each dataset and store in a list
processed_datasets <- list()

for (dataset_name in dataset_names) {
  file_path <- file.path("../data", dataset_name)
  processed_dataset <- process_dataset(file_path)
  processed_datasets[[dataset_name]] <- processed_dataset
}

# Merge datasets based on the "Date" column
merged_data <- reduce(processed_datasets, left_join, by = "Date")

# Sum the values for each search term for a given date
df_summed <- merged_data %>%
  rowwise() %>%
  mutate(Sum_SearchCount = sum(c_across(starts_with("SearchCount"))))

# Normalize the Sum_SearchCount values between 1 and 100
df_summed$SearchRatio <- df_summed$Sum_SearchCount / 8

# Print the result
df_gtrends <- df_summed[,-(2:10)]

# Displayed clean data
reactable(df_gtrends,
          sortable = TRUE, 
          searchable = TRUE)
```


### 2.2.3 Cleaning of demographic_data

The main issue with this data set was to transform it in a way that makes it useful for our analysis. We 
first had to remove all rows containing category summaries in the middle of the data.

We then formulated to following hypothesizes:

- Male and Female present the same attitude towards electric vehicles
- Swiss and Foreign citizen living in Switzerland present the same attitude towards electric vehicles
- Only people allowed to drive have an impact on electric vehicles use With these hypothesizes.

We then decided to do the following cleaning:

- Only kept the “Total” for the Male-Female category
- Only kept the “Total” for the Swiss-Foreign category
- Only kept people aged between 18 and 99. (People aged over 99 account for 0.02% of the population)

Then, instead of keeping a raw data set with all ages between 18 and 99, we decided to group them 
in widely accepted age segments, namely Generation Z, Millennials, Generation X and Baby boomers, 
to then be able to analyze if different generations have a different approach to their mobility.

```{r}
# We only keep the data from 2005-2022 (time frame of our analysis)

demographic_data <- demographic_data[-c(1:31212),]

# We do not differentiate Male-Female for the purpose of this analysis -> we only keep the "total" rows
filtered_demographic <- demographic_data %>%
  filter(grepl("total",demographic_data$Sex))

# We do not differentiate Swiss citizenship - Foreign citizenship for the purpose of this analysis -> we only keep the "total" rows
filtered_demographic <- filtered_demographic %>%
  filter(grepl("total", filtered_demographic$Citizenship..category.))

# People under 18 cannot drive -> We remove summary rows +  people under 18 + people 99 and above (anecdotal observations)
filtered_demographic <- filtered_demographic %>%
  filter(
    !grepl("total",filtered_demographic$Age),
    between(as.numeric(gsub(" years","",filtered_demographic$Age)), 18, 98)
  )

# We keep the interesting columns
filtered_demographic <- filtered_demographic %>%
  select(c("Year","Age","Population.on.1.January"))

## To perform meaningful analyses on the data, we group the ages by generations

# remove " years" from the age column
filtered_demographic$Age <- as.numeric(gsub(" years", "",filtered_demographic$Age))

# Create bins with the different generations:
filtered_demographic$Generation <- cut(filtered_demographic$Age,
                                       breaks = c(17, 26, 42, 58, Inf),
                                       labels = c("Generation Z", "Millenials","Generation X", "Baby Boomers"),
                                       include.lowest = TRUE)
# we format the table wider
filtered_demographic <- filtered_demographic %>%
  select(-"Age")
  
df_demographic <- filtered_demographic %>%
  pivot_wider(names_from = Generation, values_from = Population.on.1.January, values_fn = sum)


# Displayed clean data
reactable(df_demographic,
          sortable = TRUE, 
          searchable = TRUE)
```

### 2.2.4 Data Wrangling : Swiss vehicle clean

#### Redundancy

The dataset, representing new vehicle registrations in Switzerland from 2005 onwards, exhibited redundancy in its structure. For example, the data contained both main categories (like '> Passenger cars') and their respective sub-categories ('... Passenger car' and '.. Heavy passenger car'). On examination, it was observed that the counts under the main categories were simply aggregates of the counts of their sub-categories. Such redundancy could lead to double counting in analytical processes.

We addressed this issue by removing main categories that were aggregates of their sub-categories, preventing potential double counting in analyses. For two subsets of data (2005 to 2008 and 2009 to 2022), We filtered out main categories, cleaned and standardized the column names, reshaped the dataset from wide to long format to facilitate analysis, and extracted and formatted the year information for each observation. This process allowed for a more granular and consistent dataset for further analysis and interpretation.

```{r}
##### 1st data 2005 to 2008 clean #####
# remove the main categories to avoid  and to work with a more granular dataset.
# Filter out main categories (rows starting with '>')
v_2005_2008 <- vehicle_data_2005_2008 |>
  filter(!grepl("^>", trimws(Vehicle.group...type)))
#rename the Vehicle.group...type column to VehicleType and clean the observations' names
v_2005_2008 <- v_2005_2008 |>
  rename(Location = Canton,
         VehicleType = Vehicle.group...type) |>
  mutate(VehicleType = str_remove(VehicleType, "^\\.\\.\\.\\s*"))


# Year Extraction, Reshape the dataset from wide to long format
v_2005_2008 <- v_2005_2008 |>
  pivot_longer(cols = `X2005`:`X2008`, names_to = "Year", values_to = "Count")
# Remove the "X" prefix from the Year column
v_2005_2008$Year <- gsub("X", "", v_2005_2008$Year)


##### 2nd data 2009 to 2022 clean #####
# Filter out main categories (rows starting with '>')
v_2009_2022 <- vehicle_data_2009_2022 |>
  filter(!grepl("^>", trimws(Vehicle.group...type)))
#rename the Vehicle.group...type column to VehicleType and clean the observations' names
v_2009_2022 <- v_2009_2022 |>
  rename(Location = Canton,
         VehicleType = Vehicle.group...type) |>
  mutate(VehicleType = str_remove(VehicleType, "^\\.\\.\\.\\s*"))

# Year Extraction, Reshape the dataset from wide to long format
v_2009_2022 <- v_2009_2022 |>
  pivot_longer(cols = `X2009`:`X2022`, names_to = "Year", values_to = "Count")
# Remove the "X" prefix from the Year column
v_2009_2022$Year <- gsub("X", "", v_2009_2022$Year)
```

#### Merging and Joining
As the vehicle data was split across multiple files, it was necessary to combine them for a holistic view.

We used `bind_rows`to create df_v, then sorted the dataset by yearto ensure a structured chronological view of the data.

```{r}
df_v <- bind_rows(v_2005_2008, v_2009_2022)
df_v <- df_v |>
  arrange(df_v$Year)
```

#### Refinement and Vehicle Classification Insights

* Some of the canton names have special characters that haven't been encoded properly in the dataset, causing them to display as hexadecimal escape sequences. To address this, we used `iconv` to properly encode these characters from "latin1" to "UTF-8". Additionally, when multiple names were provided for cantons (separated by slashes), we retained only the first name using `sapply` and `str_split`. We standardized the canton names using a predefined list (`standard_names`).
* We created a unified date column by combining 'Year' and 'Month' information. First, we matched month names to their corresponding numeric values, then merged this information with the year, and formatted it as "YYYY-MM-01" to generate a standard date format.This transformation streamlines time series analyses and provides a more intuitive representation of the data's temporal dimension.

We simplified the classification of hybrid vehicles by merging different categories of conventional and plug-in hybrids into two main groups: "Conventional hybrid" and "Plug-in hybrid", respectively. This simplification aimed to streamline analysis by grouping similar types together.

The "Gas" fuel type was renamed from "Gas (monovalent and bivalent)" for clarity and consistency in the dataset.

Further context was provided on different *hybrid types*:

Conventional Hybrids: These vehicles, powered by petrol or diesel **without** plug-in capability, might exhibit different adoption trends due to their longer existence in the market.Have been around longer and may have a different adoption trend compared to newer technologies.

Plug-in Hybrids: With larger batteries and the ability to charge from an electric outlet, these vehicles enable all-electric operation for limited distances. The presence of charging infrastructure might impact their adoption differently, distinguishing them from conventional hybrids. Adoption might be reflected differently due to the need for charging infrastructure.

```{r}
#### canton ####
df_v$Location <- iconv(df_v$Location, from = "latin1", to = "UTF-8")

# keep only the first name when multiple names are provided for cantons (separated by slashes)
df_v$Location <- sapply(str_split(df_v$Location, " / "), `[`, 1)

# Standardizing the cantons names:
standard_names <- c("Switzerland" = "Switzerland", "Zürich" = "ZH", "Bern" = "BE", "Luzern" = "LU", "Uri" = "UR", "Schwyz" = "SZ",
                    "Obwalden" = "OW", "Nidwalden" = "NW","Glarus" = "GL", "Zug" = "ZG", "Fribourg" = "FR", "Solothurn" = "SO",
                    "Basel-Stadt" = "BS", "Basel-Landschaft" = "BL", "Schaffhausen" = "SH", "Appenzell Ausserrhoden" = "AR",
                    "Appenzell Innerrhoden" = "AI", "St. Gallen" = "SG", "Graubünden" = "GR", "Aargau" = "AG", "Thurgau" = "TG",
                    "Ticino" = "TI", "Vaud" = "VD", "Valais" = "VS", "Neuchâtel" = "NE", "Genève" = "GE", "Jura" = "JU",
                    "Confederation" = "Confederation")
df_v$Location <- standard_names[df_v$Location]

#### Year ####
#create date col
# Convert month names to month numbers
df_v$MonthNum <- match(df_v$Month, month.name)
# Combine Year, MonthNum, and "01" to create a date in the format "YYYY-MM-01"
df_v$Date <- as.Date(paste(df_v$Year, df_v$MonthNum, "01", sep = "-"), format = "%Y-%m-%d")
# Drop the Month, Year, and MonthNum columns
df_v <- df_v %>% select(-Month, -Year, -MonthNum)


#### renaming ####
#renaming the 4 different hybrid name to only two
df_v <- df_v |>
  mutate(Fuel = case_when(
    Fuel %in% c("Petrol-electricity: conventional hybrid", "Diesel-electricity: conventional hybrid") ~ "Conventional hybrid",
    Fuel %in% c("Petrol-electricity: plug-in hybrid", "Diesel-electricity: plug-in hybrid") ~ "Plug-in hybrid",
    TRUE ~ Fuel # Keeps all other fuel types as they are
  ))

#renaming fuel type: gas
df_v <- df_v |>
  mutate(Fuel = if_else(Fuel == "Gas (monovalent and bivalent)", "Gas", Fuel))
```


```{r}
#count nbr of vehicle for a paticular year and 
vehicle_count_2022 <- df_v |>
  filter(Location == "Switzerland", year(Date) == 2023, VehicleType == "Passenger car") |>
  summarize(TotalCount = sum(Count))
```


#### Rows with 0
Retaining rows with a Count of 0 ensures the completeness of our dataset, indicating periods when specific vehicle types or fuel categories had no registrations. This not only provides a holistic view of vehicle adoption trends over time but also aids in generating continuous time series visualizations without gaps, offering a true representation of the data.

```{r}
# Displayed clean data
#reactable(df_v, sortable = TRUE, searchable = TRUE)
```


### 2.2.5 Data wrangling French vehicle clean

This dataset will be used to compare our data in Switzerland with a bordering country (FR)

It is important to note that this data set contains all registered vehicles in a given year (vs. all new registered cars for our Swiss data)
We will only keep the vehicles used for personal use (not the ones for professional use), to match our Swiss dataset

We decided to remove some anecdotal observations (i.e Hydrogen, Unknown, etc.) as their production / use is marginal. Moreover, we have decided to regroup the different kind of hybrid motors into a single "Hybrid" category.

The main issue with this data set was to set it in a way where it is comparable to our Swiss cars data 
set. Indeed, this dataset presents the total of all cars in France for a given year and type, while our 
Swiss data set accounts for new registration of cars for a given year and type.

To be able to compare two data sets, we decided to format the French data set in the following way:

- Remove categories that are not relevant for our analysis, and widely under-represented in the population (i.e Gaz, hydrogen)
- Focus on the private use of cars (vs. professional), because the decision to use a certain type of cars for professional reasons are often explained by factors hard to capture in our analysis (i.e bundle deals, greenwashing). We therefore hypothesized that private use of a certain type of car better gives insights on population view.
- The match our swiss data set (new registration per year), we computed the difference of total cars registered in France per years. Having only the data between 2011 and 2022, we have “lost” the insights for 2011. Indeed, when creating the deltas (difference) columns, 2011 deltas could not be computed (no data for 2010), we therefore decided to delete that year from our data

```{r}

# the first three rows are empty
france_v <- france_v[- c(1,2,3),]

# Only taking the private cars from this data
france_private <- france_v[25:37,]


# pivoting to match the Swiss data set and correctly setting the column names
france_private <- t(france_private)
colnames(france_private) <- france_private[1,]
france_private <- france_private[-1,]

# Removing "Particulier" ( =aggregate of all categories), "Gaz" (<1% of cars), "Unknown" (muddies the data), "Hydrogen (anecdotal observations)
france_private <- as_tibble(france_private)

france_private <- france_private %>%
  select(-c("Particulier", "Gaz", "Gaz HNR", "Gaz HR", "Hydrogène et autre ZE", "Inconnu"))

# Add info about the year
france_private <- france_private %>%
  mutate(Year = 2011:2022)

# Removing the decimals due to previous manipulations
for (i in 1:(ncol(france_private) - 2)) {  # Exclude the last two columns (Year and Hybrid)
  france_private[12, i] <- as.character(floor(as.numeric(france_private[12, i])))
}

# To match swiss data set: creating the Conventional Hybrid and Plug-in Hybrid categories (aggregating the different kinds of hybrid) and removing the aggregated columns
france_private <- france_private %>%
  mutate(
    Conventional_Hybrid = as.numeric(`Diesel HNR`)+ as.numeric(`Essence HNR`),
    Plug_in_Hybrid = as.numeric(`Diesel HR`) + as.numeric(`Essence HR`)
  )

france_private <- france_private %>%
  select(Diesel, Essence, Conventional_Hybrid, Plug_in_Hybrid, Electrique, Year)

# To match our Swiss data set, we need to deltas (change) between each years
france_private <- france_private %>%
  mutate(across(c(Diesel, Essence, Conventional_Hybrid, Plug_in_Hybrid, Electrique), as.numeric),
         Diesel_delta = Diesel - lag(Diesel),
         Essence_delta = Essence - lag(Essence),
         Conventional_Hybrid_delta = Conventional_Hybrid - lag(Conventional_Hybrid),
         Plug_in_Hybrid_delta = Plug_in_Hybrid - lag(Plug_in_Hybrid),
         Electrique_delta = Electrique - lag(Electrique))

# Removing the NAs I've created with the lag function (2011 deltas were NA because we don't have data for 2010)
france_private <- france_private[-1,]

# Ordering the columns for more clarity
df_v_fr <- france_private %>%
  select(c("Year", "Diesel", "Diesel_delta", "Essence", "Essence_delta", "Conventional_Hybrid", "Conventional_Hybrid_delta", "Plug_in_Hybrid", "Plug_in_Hybrid_delta", "Electrique", "Electrique_delta"))


#convert date into datetime format
# Assuming 'Year' is an integer column representing the year
df_v_fr$Date <- as.Date(paste(df_v_fr$Year, "-01-01", sep = ""), format = "%Y-%m-%d")
# Rearrange columns with 'Date' as the first column and drop 'year' and 'month'
df_v_fr <- df_v_fr %>%
  select(Date, everything()) %>%
  select(-Year)

# Displayed clean data
reactable(df_v_fr,
          sortable = TRUE, 
          searchable = TRUE)
```

### 2.2.6 Availability of charging stations

This data set will be used to explore and analyze the effects of charging station availability on EVs adoption.

However, two important points are to note.

1. We were unable to find data before November 2020
2. Charging station availability and EV in market are likely strongly reciprocally correlated.

Moreover, it is important to keep standardized dates and locations

We merges 'year' and 'month' columns to create a 'Date' column in the format "YYYY-MM-01", subsequently reorganizing the dataframe to position 'Date' as the first column and removing the original 'year' and 'month' columns.
```{r}
# Combine 'year' and 'month' columns to create a new 'Date' column
charging_station$Date <- as.Date(paste(charging_station$year, charging_station$month, "01", sep = "-"))

# Rearrange columns with 'Date' as the first column and drop 'year' and 'month'
df_charging_station <- charging_station %>%
  select(Date, everything()) %>%
  select(-year, -month)
```

```{r}
# Displayed clean data
reactable(df_charging_station,
          sortable = TRUE, 
          searchable = TRUE)
```

