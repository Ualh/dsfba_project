# 2 Data

```{r, echo = FALSE, message = FALSE}
source(here::here("scripts/setup.R"))
```

## 2.1 Raw Datasets

Use a Loop for Similar Files.

Check for Large Data: If any of our datasets are particularly large
(like the `swiss_vehicle`), we used a more efficient data reading
librariy `data.table` (with `fread`) to speed up the data loading
process.

We also added a common file path prefix ("../data/") to make the code
cleaner and easier to change for any usage in the future.

```{r}
library(data.table)
file_path <- "../data/"

google_trends_files <- paste0(file_path, "googletrends_", c("auto-elettrica", "elektro-auto", "elektrofahrzeug", "elektromobil", "eletric-car", "EV", "vehicule-electrique", "voiture-electrique"), "_2005-2022.csv")
google_trends_data <- lapply(google_trends_files, fread)
vehicle_data_2005_2008 <- fread(paste0(file_path, "road_vehicle_CH_2005-2008.csv"))
vehicle_data_2009_2022 <- fread(paste0(file_path, "road_vehicle_CH_2009-2022.csv"))
oil_prices_data <- fread(paste0(file_path, "BrentOilPrices.csv"))
demographic_data <- fread(paste0(file_path, "demographic.csv"))
charging_station <- fread(paste0(file_path, "charging_station.csv"))
france_v <- read_excel(paste0(file_path, "parc_vp_france_2022.xlsx"), sheet = 2)
political_data_sheets_prep <- excel_sheets(paste0(file_path, "political_data.xlsx"))
df_swisspop_2022 <- read_excel(paste0(file_path, "swiss_pop.xlsx"), sheet = 1)
df_swisspop_2021 <- read_excel(paste0(file_path, "swiss_pop.xlsx"), sheet = 2)
df_swisspop_2020 <- read_excel(paste0(file_path, "swiss_pop.xlsx"), sheet = 3)
df_swisspop_2019 <- read_excel(paste0(file_path, "swiss_pop.xlsx"), sheet = 4)
df_swisspop_2018 <- read_excel(paste0(file_path, "swiss_pop.xlsx"), sheet = 5)
charge_ch_fr <- fread(paste0(file_path,"df_charging_points_CH_FR.csv"))
```

For this phase of the project, our approach involves presenting diverse
datasets in a table form. To achieve this, we used the `kable` function
from the `kableExtra` package, resulting in a table that displays each
variable along with its corresponding definition and also added some
`bootstrap_otions` for different stlyles.

### 2.1.1 Swiss Vehicle Registration Dataset

This data set explains the new registrations of road vehicles by vehicle
group, canton, vehicle type, fuel, month and year in Switzerland. This
data set is essential to evaluate the EVs' evolution within our chosen
location.

```{r}
# Create a tibble with variable descriptions
variable_table_vehicle <- tibble(
  Variable = c("Canton", "Vehicle Group / Type", "Fuel", "Month", "2009-2022"),
  Description = c(
    "The region in Switzerland.",
    "Type or group of the vehicle.",
    "Type of fuel used by the vehicle.",
    "The month of the data.",
    "Number of vehicles for each respective year. Each with its own column"
  )
)

# Display the table using kableExtra
variable_table_vehicle %>%
  kbl() %>%
  kable_styling(position = "center", bootstrap_options = c("striped", "bordered", "hover"))
```

Source -
[bfs.admin.ch](https://www.bfs.admin.ch/bfs/en/home/statistics/catalogues-databases/data.assetdetail.24105892.html)

### 2.1.2 Oil price Dataset

This data set explains the evolution of the price of brent oil over
time. From this data set, we will be able to obtain precious information
to compute our linear regressions concerning oil price and EVs
adoptions.

```{r}
# Create a tibble with variable descriptions
variable_table <- tibble(
  Variable = c("Date", "Price"),
  Description = c(
    "The date when the price was recorded. In a day-month-year format.",
    "The price of Brent Oil on the given date."
  )
)

# Display the table using kableExtra
variable_table %>%
  kbl() %>%
  kable_styling(position = "center", bootstrap_options = c("striped", "bordered", "hover", "condensed"))
```

Source -
[Kaggle.com](https://www.kaggle.com/datasets/mabusalah/brent-oil-prices)

### 2.1.3 Swiss Demographics Dataset

While this dataset contains a substantial amount of information, only a
fraction of it will be pertinent to our research. It explains the
evolution of the Swiss population over time through variables given
below.

```{r}
# Create a tibble with variable descriptions
variable_table <- tibble(
  Variable = c(
    "Year", "Citizenship (category)", "Sex", "Age", "Population on 1 January", 
    "Live birth", "Death", "Natural change", 
    "Immigration incl. change of population type", "Emigration", 
    "Net migration incl. change of population type", 
    "Change of population type", "Acquisition of Swiss citizenship", 
    "Gender change in the civil register (entry)", 
    "Gender change in the civil register (exit)", "Statistical adjustment", 
    "Population on 31 December", "Population change"
  ),
  Description = c(
    "The year of the demographic data.",
    "The categorization of the citizenship status.",
    "Gender category.",
    "Age category.",
    "Population count at the beginning of the year.",
    "Number of births in the year.",
    "Number of deaths in the year.",
    "Change in the population due to births and deaths.",
    "Number of immigrants, including change of population type.",
    "Number of emigrations.",
    "Net migration count, including change of population type.",
    "Change in the categorization of the population.",
    "Number of individuals who acquired Swiss citizenship.",
    "Number of gender changes registered (entry).",
    "Number of gender changes registered (exit).",
    "Adjustments made to the data for accuracy.",
    "Population count at the end of the year.",
    "Change in population over the year."
  )
)

# Display the table using kableExtra
variable_table %>%
  kbl() %>%
  kable_styling(position = "center", bootstrap_options = c("striped", "bordered", "hover", "condensed"))

```

Source -
[bfs.admin.ch](https://www.bfs.admin.ch/bfs/en/home/statistics/catalogues-databases/data.assetdetail.26645079.html)

### 2.1.4 Google trend data

This Data set shows the evolution of Google trends on 8 different terms.
We chose these terms in all 3 different main Swiss national languages
(French, Italian and German) to make sure we get the most accurate data
possible. Those variables will help us highlight potential
tendencies/trends.

```{r}
# Create a tibble with variable descriptions for Google Trends data
variable_table_google_trend <- tibble(
  Variable = c("Month", 
                "Search Term: Voiture électrique", 
                "Search Term: Véhicule électrique", 
                "Search Term: EV", 
                "Search Term: Electric Car", 
                "Search Term: Elektromobil", 
                "Search Term: Elektrofahrzeug", 
                "Search Term: Elektro Auto", 
                "Search Term: Auto Elettrica"),
  Description = c(
    "The month of the data",
    "Google Trends data for 'Voiture électrique: (Suisse)'",
    "Google Trends data for 'Véhicule électrique: (Suisse)'",
    "Google Trends data for 'EV: (Suisse)'",
    "Google Trends data for 'Electric car: (Suisse)'",
    "Google Trends data for 'Elektromobil: (Suisse)'",
    "Google Trends data for 'Elektrofahrzeug: (Suisse)'",
    "Google Trends data for 'Elektro Auto: (Suisse)'",
    "Google Trends data for 'Auto Elettrica: (Suisse)'"
  )
)

# Display the table using kableExtra
variable_table_google_trend %>%
  kbl() %>%
  kable_styling(position = "center", bootstrap_options = c("striped", "bordered", "hover", "condensed"))

```

Sources for Google Trends Data: - [Voiture électrique
Trends](https://trends.google.fr/trends/explore?q=voiture%20%C3%A9lectrique&date=now%201-d&geo=CH&hl=fr) -
[Véhicule électrique
Trends](https://trends.google.fr/trends/explore?date=now%201-d&geo=CH&q=v%C3%A9hicule%20%C3%A9lectrique&hl=fr) -
[EV
Trends](https://trends.google.fr/trends/explore?date=now%201-d&geo=CH&q=EV&hl=fr) -
[Electric Car
Trends](https://trends.google.fr/trends/explore?date=now%201-d&geo=CH&q=Electric%20car&hl=fr) -
[Elektromobil
Trends](https://trends.google.fr/trends/explore?date=now%201-d&geo=CH&q=Elektromobil&hl=fr) -
[Elektrofahrzeug
Trends](https://trends.google.fr/trends/explore?date=now%201-d&geo=CH&q=Elektrofahrzeug&hl=fr) -
[Elektro Auto
Trends](https://trends.google.fr/trends/explore?date=now%201-d&geo=CH&q=Elektro%20Auto&hl=fr) -
[Auto Elettrica
Trends](https://trends.google.fr/trends/explore?date=now%201-d&geo=CH&q=Auto%20elettrica&hl=fr)

### 2.1.5 French vehicle registration data

We decided to add this data set to help us compare with another country.
Indeed, France is an adjacent country which might imply potential
similarities in the outcome. This data set is made of variables such as
the Date of the French vehicle registration or whether it is from a
professional user or not. The information we are interested in concern
the number of registered vehicles in the country by propulsion method
over time.

```{r}
# Create a tibble with variable descriptions for vehicle categorization data
variable_table <- tibble(
  Variable = c("Date", "Ensemble des voitures particulieres", "Professionnel", "Particulier", "Crit'Air"),
  Description = c(
    "The date, in year format, in which the observations are registered",
    "The sum of vehicle in every groups",
    "Category 'Professional' of vehicle",
    "Category 'Passenger Car' of vehicle",
    "Categorizes vehicles by emissions with from best to worst classes"
  )
)

# Display the table using kableExtra
variable_table %>%
  kbl() %>%
  kable_styling(position = "center", bootstrap_options = c("striped", "bordered", "hover", "condensed"))

```

Source - [Auto Elettrica
Trends](https://www.statistiques.developpement-durable.gouv.fr/donnees-sur-le-parc-de-vehicules-en-circulation-au-1er-janvier-2022)

### 2.1.6 Charging Stations

This data set is meant to determine the number of charging stations per
canton, per charging power, per month, per plug type in Switzerland
since November 2020. It is important to mention that a station can have
multiple charging points. These values will help us to obtain more
information about the Swiss adaption to EVs and their potential effects
on EVs adoption by the Swiss population

```{r}
# Create a tibble with variable descriptions in English for charging station data
variable_table_charging <- tibble(
  Variable = c("year",
                "month",
                "stations_CH_count",
                "stations_XY_count",
                "locations_CH_count",
                "locations_XY_count",
                "plugs_CH_count",
                "plugs_XY_count",
                "chargingPower_CH_sum",
                "chargingPower_XY_sum",
                "chargingPower_CH_count",
                "chargingPower_XY_count",
                "chargingPower_10kW_count",
                "chargingPower_21kW_count",
                "chargingPower_42kW_count"),
  Description = c(
    "Year of the key figures collection.",
    "Month of the key figures collection. These are collected daily and published monthly.",
    "Number of available charging stations in Switzerland. A station can have multiple charging points.",
    "Number of charging stations per canton. A station can have multiple charging points. This attribute is available for all cantons, XY representing the official canton abbreviation.",
    "Number of stations in Switzerland. A station can have multiple charging points.",
    "Number of stations per canton. A station can have multiple charging points. This attribute is available for all cantons, XY representing the official canton abbreviation.",
    "Number of charging plugs in Switzerland.",
    "Number of charging plugs per plug type in Switzerland. This attribute is available for all plug types, XY corresponding to the plug type according to the Open Intercharge Protocol (OICP) version 2.2 (see below).",
    "Total maximum charging power in kilowatts of recharge stations in Switzerland. Only charging points with known power are considered (see chargingPower_CH_count).",
    "Total maximum charging power in kilowatts of recharge stations in a canton. Only charging points with known power are considered (see chargingPower_XY_count).",
    "Number of recharge stations in Switzerland with known maximum charging power and for which the total maximum charging power has been taken into account (chargingPower_CH_sum).",
    "Number of recharge stations per canton with known maximum charging power and for which the total maximum charging power has been taken into account (chargingPower_XY_sum).",
    "Number of recharge stations in Switzerland with known maximum charging power delivering a maximum charging power of 10 kW.",
    "Number of recharge stations in Switzerland with known maximum charging power ranging from over 10 kW to 21 kW.",
    "Number of recharge stations in Switzerland with known maximum charging power ranging from over 21 kW to 42 kW."
  )
)

# Display the table using kableExtra
variable_table_charging %>%
  kbl() %>%
  kable_styling(position = "center", bootstrap_options = c("striped", "bordered", "hover", "condensed"))
```

Source - \[IEA.org\]
(https://www.iea.org/data-and-statistics/data-tools/global-ev-data-explorer)
\### 2.2.7 Complementary charging station

```{r}
# Create a tibble with variable descriptions for the Swiss population data set
variable_charging_station_v2 <- tibble(
  Variable = c("Region", "Category", "Parameter", "Mode","Powertrain", "Unit","Value"),
  Description = c(
    "Either Switzerland or France",
    "One category: Historical",
    "One parameter: EV charging point",
    "One mode: EV",
    "Either Publicly available fast, or Publicly availabe slow",
    "One unit: charging point",
    "The total number of available charging point for a given region, year and powertrain"
  )
)

# Display the table using kableExtra
variable_charging_station_v2 %>%
  kbl() %>%
  kable_styling(position = "center", bootstrap_options = c("striped", "bordered", "hover"))
```

Source -
[bfe.admin.ch](https://www.bfe.admin.ch/bfe/fr/home/approvisionnement/statistiques-et-geodonnees/geoinformation/geodonnees/mobilite/bornes-de-recharge-pour-la-mobilite-electrique.html)

### 2.2.8 Political strength per canton

```{r}
# Create a tibble with variable descriptions for the Swiss population data set
variable_table_politic <- tibble(
  Variable = c("Years 1971-2023", "Canton", "Political parties", "Taux de participation"),
  Description = c(
    "The years were elections to the Conseil National took place from 1971 to 2023",
    "The name of the canton in Switzerland",
    "The name of all political parties in Switzerland and their strength in a given Canton, (Canton's total = 100%), in a given   year",
    "The participation rate to the elections of the Conseil National in a given year"
  )
)

# Display the table using kableExtra
variable_table_politic %>%
  kbl() %>%
  kable_styling(position = "center", bootstrap_options = c("striped", "bordered", "hover"))
```

Source - [nom de la source](copy_paste_link)

### 2.2.7 Swiss Population

```{r}
# Create a tibble with variable descriptions for the Swiss population dataset
variable_table_swiss_pop <- tibble(
  Variable = c("Canton", "Total Population", "Age Groups", "Sex", "Citizenship", "Marital Status", "Typology: Area with urban character"),
  Description = c(
    "The name of the canton in Switzerland.",
    "Total number of permanent residents in the canton.",
    "Population broken down into age groups: 0–19, 20–64, 65 and over.",
    "Population broken down by sex: Male and Female.",
    "Population broken down by citizenship: Swiss and Foreigner.",
    "Population broken down by marital status: Single, Married, Widowed, Divorced, Unmarried, In a registered partnership, Partnership dissolved.",
    "Typology of the area based on urban character: Urban core, Area influenced by urban cores, Area beyond urban influence."
  )
)

# Display the table using kableExtra
variable_table_swiss_pop %>%
  kbl() %>%
  kable_styling(position = "center", bootstrap_options = c("striped", "bordered", "hover"))
```

Source -
[bfe.admin.ch](https://www.bfs.admin.ch/bfs/fr/home/statistiques/population.assetdetail.26565163.html)

## 2.2 Data Wrangling

### 2.2.1 Data Wrangling : Oil clean

Initially, while attempting to format the dataset, we discovered the
generation of numerous `NAs`. Upon delving deeper into the data, we
identified two distinct *date formats*: the first being \[DD-MMM-YYYY\]
and the second \[MMM DD, YYYY\]. Consequently, the initial date
formatting was ineffective. Therefore, we undertook the task of matching
the two tables with the same date format.

Another issue we encountered was to present the date in a standardized
form across all our dataset to perform time series analyses. For that,
we had to change the abbreviated months names (i.e. Jan, Feb, etc.) into
numbers.

```{r}
# Format 1: DD-MMM-YYYY (e.g., 15-Apr-2020)
oil_df_1 <- oil_prices_data[1:8360,] %>%
  separate(Date, into = c("Day", "Month", "Year"), sep = "-") %>%
  mutate(Date = dmy(paste(Day, Month, Year)))

# Format 2: MMM DD, YYYY (e.g., Apr 22, 2020)
# Handling the separator with space and comma
oil_df_2 <- oil_prices_data[8361:nrow(oil_prices_data),] %>%
  separate(Date, into = c("Month", "Day", "Year"), sep = " ", extra = "merge") %>%
  mutate(Day = word(Day, 1),  # Extracts just the day part
         Date = mdy(paste(Month, Day, Year)))

# Merge and filter for dates after 2005
df_oil <- rbind(oil_df_1, oil_df_2) %>%
  filter(year(Date) >= 2005) %>%
  select(Date, Price)

# Display cleaned data
reactable(
  df_oil,  # Use your oil prices dataframe
  columns = list(
    Date = colDef(
      align = "center",  # Center align the date column
      minWidth = 150
    ),
    Price = colDef(
      align = "right",  # Right align the price column
      style = function(value) {
        # Apply conditional formatting based on the price value
        if (value > 120) {
          color <- "green"  # Green for high prices
        } else if (value < 30) {
          color <- "red"    # Red for low prices
        } else {
          color <- "black"  # Default color for other values
        }
        list(color = color)
      }
    )
  ),
  highlight = TRUE,  # Highlight rows on hover
  defaultPageSize = 10,  # Display 10 rows per page
  paginationType = "numbers",  # Use numbers for page navigation
  searchable = TRUE,  # Make the table searchable
  sortable = TRUE,  # Allow sorting
  resizable = TRUE  # Allow column resizing
)
```

### 2.2.2 Data Wrangling : Google trend clean

Comprehending Google Trends information involves understanding the
contextualization of the provided figures. The given data is
standardized which limits the range of information we can obtain from
it.

The crucial element for effective narration lies in utilizing the
normalized Trends data. This normalization indicates that when observing
search interest trends over time, it is interpreted as a ratio relative
to all searches conducted on all topics on Google during that specific
period and location. Likewise, when assessing regional search interest
for a specific topic, it is construed as the search interest for that
particular topic in a given region relative to all searches on all
topics on Google in that same place and time.

[Source](https://medium.com/google-news-lab/what-is-google-trends-data-and-what-does-it-mean-b48f07342ee8)

To clean and process eight Google Trends datasets related to different
search terms, we created a `function process_dataset()` that reads each
CSV file, removes date indices, excludes the first row, checks for
missing values, renames columns, converts types, and standardizes the
date format. Then, we iterated through each dataset, merged them based
on the "Date" column, summed values for each search term per date, and
normalized these values between 1 and 100.

```{r}
dataset_names <- c(
  "googletrends_auto-elettrica_2005-2022.csv",
  "googletrends_elektro-auto_2005-2022.csv",
  "googletrends_elektrofahrzeug_2005-2022.csv",
  "googletrends_elektromobil_2005-2022.csv",
  "googletrends_eletric-car_2005-2022.csv",
  "googletrends_EV_2005-2022.csv",
  "googletrends_vehicule-electrique_2005-2022.csv",
  "googletrends_voiture-electrique_2005-2022.csv"
)

# Function to process each dataset
process_dataset <- function(file_path) {
  # Read the dataset
  google_trends_data <- read.csv(file_path)

  # Remove the dates from the index
  google_trends_data <- google_trends_data |> rownames_to_column(var = "Date")

  # Remove the first row using slice
  google_trends_data <- slice(google_trends_data, -1)

  # Check for NA
  cat("NA count for", file_path, ": ", sum(is.na(google_trends_data$Date)), "\n")
  cat("NA count for SearchCount in", file_path, ": ", sum(is.na(google_trends_data$Catégorie...Toutes.catégories)), "\n")

  # Rename col
  colnames(google_trends_data)[2] <- "SearchCount"

  # Convert to numeric
  google_trends_data$SearchCount <- as.numeric(google_trends_data$SearchCount)

  # Convert the column to date with the desired format
  google_trends_data$Date <- as.Date(paste(google_trends_data$Date, "01", sep = "-"))

  return(google_trends_data)
}

# Process each dataset and store in a list
processed_datasets <- list()

for (dataset_name in dataset_names) {
  file_path_gt <- file.path("../data", dataset_name)
  processed_dataset <- process_dataset(file_path_gt)
  processed_datasets[[dataset_name]] <- processed_dataset
}

# Merge datasets based on the "Date" column
merged_data <- reduce(processed_datasets, left_join, by = "Date")

# Sum the values for each search term for a given date
df_gtrends <- merged_data %>%
  rowwise() %>%
  mutate(Sum_SearchCount = sum(c_across(starts_with("SearchCount"))))

# Normalize the Sum_SearchCount values between 1 and 100
df_gtrends$SearchRatio <- df_gtrends$Sum_SearchCount / 8

# Print the result
df_gtrends <- df_gtrends[,-(2:10)]

#display cleaned data
reactable(
  df_gtrends,
  columns = list(
    Date = colDef(
      align = "center",  # Center align the date column
      minWidth = 150
    ),
    SearchRatio = colDef(
      align = "right",  # Right align the SearchRatio column
      style = function(value) {
        if (value > 45) {
          color <- "green"  # Green for values greater than 50
        } else if (value < 5) {
          color <- "red"    # Red for values less than 5
        } else {
          color <- "black"  # Default color for other values
        }
        list(color = color)
      }
    )
  ),
  highlight = TRUE,  # Highlight rows on hover
  defaultPageSize = 10,  # Display 10 rows per page
  paginationType = "numbers",  # Use numbers for page navigation
  searchable = TRUE,  # Make the table searchable
  sortable = TRUE,  # Allow sorting
  resizable = TRUE  # Allow column resizing
)
```

### 2.2.3 Cleaning of demographic_data

The main issue with this data set was to transform it in a way that
makes it useful for our analysis. We first had to remove all rows
containing category summaries in the middle of the data.

We then formulated to following hypothesizes:

-   Male and Female present the same attitude towards electric vehicles
-   Swiss and Foreign citizen living in Switzerland present the same
    attitude towards electric vehicles
-   People who are not allowed to drive do not have any impact on
    electric vehicles use

We then decided to do the following cleaning:

-   Only kept the "Total" for the Male-Female category
-   Only kept the "Total" for the Swiss-Foreign category
-   Only kept people aged between 18 and 99. (People aged over 99
    account for 0.02% of the population)

Then, instead of keeping a raw data set with all ages between 18 and 99,
we decided to group them in widely accepted age segments, namely
Generation Z, Millennials, Generation X and Baby boomers. This
categorization will help us to analyse whether different generations
have a different approach to their mobility or not.

```{r}
# Clean and process the demographic data
df_demographic <- demographic_data %>%
  filter(Year >= 2005, Year <= 2022) %>%
  filter(str_detect(Sex, "total"), str_detect(`Citizenship (category)`, "total")) %>%
  mutate(Age_clean = gsub(" years", "", Age)) %>%
  filter(!str_detect(Age_clean, "total")) %>%
  mutate(Age_num = as.numeric(Age_clean)) %>%
  filter(!is.na(Age_num), Age_num >= 18, Age_num <= 98) %>%
  select(Year, Age = Age_num, `Population on 1 January`) %>%
  mutate(
    Generation = cut(Age, breaks = c(17, 26, 42, 58, Inf), labels = c("Generation Z", "Millennials", "Generation X", "Baby Boomers"), include.lowest = TRUE),
    Year = ymd(paste(Year, "01", "01", sep = "-")) # Converting Year to Date format
  ) %>%
  group_by(Year, Generation) %>%
  summarise(Population = sum(`Population on 1 January`, na.rm = TRUE)) %>%
  pivot_wider(names_from = Generation, values_from = Population)

reactable(
  df_demographic, 
  columns = list(
    Year = colDef(
      align = "center",  # Center align the year column
      minWidth = 100
    ),
    `Generation Z` = colDef(
      align = "right",  # Right align the population column
      style = function(value) {
        color <- ifelse(value > 860000, "green", "black")  # Green for population over 1 million
        list(color = color)
      }
    ),
    Millennials = colDef(
      align = "right",
      style = function(value) {
        color <- ifelse(value > 1900000, "green", "black")
        list(color = color)
      }
    ),
    `Generation X` = colDef(
      align = "right",
      style = function(value) {
        color <- ifelse(value > 2000000, "green", "black")
        list(color = color)
      }
    ),
    `Baby Boomers` = colDef(
      align = "right",
      style = function(value) {
        color <- ifelse(value > 2300000, "green", "black")
        list(color = color)
      }
    )
  ),
  highlight = TRUE,  # Highlight rows on hover
  defaultPageSize = 10,  # Display 10 rows per page
  paginationType = "numbers",  # Use numbers for page navigation
  searchable = TRUE,  # Make the table searchable
  sortable = TRUE,  # Allow sorting
  resizable = TRUE  # Allow column resizing
)
str(df_demographic)
```

### 2.2.4 Data Wrangling : Swiss vehicle clean

```{r}
# Define a function to process vehicle data, excluding the first row as it's not actual data
process_vehicle_data <- function(vehicle_data, start_year, end_year) {
  # the first row is a header or metadata and should be excluded
  vehicle_data <- vehicle_data[-1, ]
  
  col_names <- c("Canton", "VehicleGroupType", "Fuel", "Month", paste0("X", start_year:end_year))
  names(vehicle_data) <- col_names
  
  vehicle_data %>%
    filter(!str_detect(trimws(VehicleGroupType), "^>")) %>%
    rename(Location = Canton, VehicleType = VehicleGroupType) %>%
    mutate(VehicleType = str_remove(VehicleType, "^\\.\\.\\.\\s*")) %>%
    pivot_longer(cols = all_of(paste0("X", start_year:end_year)), names_to = "Year", values_to = "Count") %>%
    mutate(Year = as.numeric(str_remove(Year, "X")),
           MonthNum = match(Month, month.name),
           Date = as.Date(paste(Year, ifelse(is.na(MonthNum), 1, MonthNum), "01", sep = "-"), format = "%Y-%m-%d")) %>%
    select(-Month, -Year, -MonthNum)
}

# Process 2005 to 2008 and 2009 to 2022 data
v_2005_2008 <- process_vehicle_data(vehicle_data_2005_2008, 2005, 2008)
v_2009_2022 <- process_vehicle_data(vehicle_data_2009_2022, 2009, 2022)

# Merge and arrange data
df_v <- bind_rows(v_2005_2008, v_2009_2022) %>%
  arrange(Date)

# Canton and Fuel Type Standardization
standard_names <- c(
  "Switzerland" = "Switzerland", "Zürich" = "ZH", "Bern" = "BE", "Luzern" = "LU",
  "Uri" = "UR", "Schwyz" = "SZ", "Obwalden" = "OW", "Nidwalden" = "NW",
  "Glarus" = "GL", "Zug" = "ZG", "Fribourg" = "FR", "Solothurn" = "SO",
  "Basel-Stadt" = "BS", "Basel-Landschaft" = "BL", "Schaffhausen" = "SH",
  "Appenzell Ausserrhoden" = "AR", "Appenzell Innerrhoden" = "AI", 
  "St. Gallen" = "SG", "Graubünden" = "GR", "Aargau" = "AG", 
  "Thurgau" = "TG", "Ticino" = "TI", "Vaud" = "VD", "Valais" = "VS",
  "Neuchâtel" = "NE", "Genève" = "GE", "Jura" = "JU", "Confederation" = "Confederation"
)

df_v <- df_v %>%
  mutate(Location = iconv(Location, from = "latin1", to = "UTF-8")) %>%
  mutate(Location = map_chr(str_split(Location, " / "), ~ .x[1])) %>%
  mutate(Location = standard_names[Location],
         Fuel = case_when(
           Fuel %in% c("Petrol-electricity: conventional hybrid", "Diesel-electricity: conventional hybrid") ~ "Conventional hybrid",
           Fuel %in% c("Petrol-electricity: plug-in hybrid", "Diesel-electricity: plug-in hybrid") ~ "Plug-in hybrid",
           Fuel == "Gas (monovalent and bivalent)" ~ "Gas",
           TRUE ~ Fuel))

# Count number of vehicles for a particular year
#vehicle_count_2022 <- df_v %>%
#  filter(Location == "Switzerland", year(Date) == 2023, VehicleType == "Passenger car") %>%
#  summarize(TotalCount = sum(Count))
```

#### Redundancy

The dataset, representing new vehicle registrations in Switzerland from
2005 onwards, exhibited redundancy in its structure. For example, the
data contained both main categories (like '\> Passenger cars') and their
respective sub-categories ('... Passenger car' and '.. Heavy passenger
car'). On examination, it was observed that the counts under the main
categories were simply aggregates of the counts of their sub-categories.
Such redundancy could lead to double counting in analytical processes.

We addressed this issue by removing main categories that were aggregates
of their sub-categories, preventing potential double counting in
analyses. For two subsets of data (2005 to 2008 and 2009 to 2022), We
filtered out main categories, cleaned and standardized the column names,
reshaped the data set from wide to long format to facilitate analysis,
and extracted and formatted the year information for each observation.
This process allowed for a more granular and consistent data set for
further analysis and interpretation.

#### Merging and Joining

As the vehicle data was split across multiple files, it was necessary to
combine them for a holistic view.

We used `bind_rows`to create `df_v`, then sorted the dataset by year to
ensure a structured chronological view of the data.

#### Refinement and Vehicle Classification Insights

-   Some canton names in the dataset had special characters not properly
    encoded, displaying as hexadecimal escape sequences. To correct
    this, we used `iconv` to properly encode these characters from
    "latin1" to "UTF-8". Additionally, where multiple names were
    provided for cantons (separated by slashes), we retained only the
    first name. We standardized the canton names using a predefined list
    (`standard_names`).
-   We unified the date representation by combining 'Year' and 'Month'
    information, matching month names to their corresponding numeric
    values, then merged this information with the year, and formatted it
    as "YYYY-MM-DD" to generate a standard date format. This
    transformation streamlines time series analyses and provides a more
    intuitive representation of the data's temporal dimension.

We simplified the classification of hybrid vehicles by merging different
categories of conventional and plug-in hybrids into two main groups:
"Conventional hybrid" and "Plug-in hybrid", respectively. This
simplification aimed to streamline analysis by grouping similar types
together.

The "Gas" fuel type was renamed from "Gas (monovalent and bivalent)" for
clarity and consistency in the dataset.

Further context was provided on different *hybrid types*:

Conventional Hybrids: These vehicles, powered by petrol or diesel
**without** plug-in capability, might exhibit different adoption trends
due to their longer existence in the market.Indeed, they have been
around for longer and may have a different adoption trend compared to
newer technologies.

Plug-in Hybrids: With larger batteries and the ability to charge from an
electric outlet, these vehicles enable all-electric operation for
limited distances. The presence of charging infrastructure might impact
their adoption differently, distinguishing them from conventional
hybrids. Adoption might be reflected differently due to the need for
charging infrastructure.

#### Rows with 0

Retaining rows with a Count of 0 ensures the completeness of our
dataset, indicating periods when specific vehicle types or fuel
categories had no registrations. This not only provides a holistic view
of vehicle adoption trends over time but also aids in generating
continuous time series visualizations without gaps, offering a true
representation of the data.

```{r}
# Display cleaned data
reactable(head(df_v, 500), sortable = TRUE, searchable = TRUE)
```

### 2.2.5 Data wrangling French vehicle clean

This dataset will be used to compare our data in Switzerland with a
bordering country (FR)

It is important to note that this data set contains all registered
vehicles in a given year (vs. all new registered cars for our Swiss
data) We will only keep the vehicles used for personal use (not the ones
for professional use), to match our Swiss dataset

We decided to remove some anecdotal observations (i.e Hydrogen, Unknown,
etc.) as their production / use is marginal. Moreover, we have decided
to regroup the different kind of hybrid motors into two Hybrid
categories. The 2 categories are the plugable hybrid vehicle HR (petrol
or diesel) and the non-plugable hybrid vehicles HNR (petrol or diesel).
This was done to match our Swiss data set.

The main issue with this data set was to set it in a way where it is
comparable to our Swiss cars data set. Indeed, this dataset presents the
total of all cars in France for a given year and type, while our Swiss
data set accounts for new registration of cars for a given year and
type.

To be able to compare two data sets, we decided to format the French
data set in the following way:

-   Remove categories that are not relevant for our analysis, and widely
    under-represented in the population (i.e Gaz, hydrogen)
-   Focus on the private use of cars (vs. professional), because the
    decision to use a certain type of cars for professional reasons are
    often explained by factors hard to capture in our analysis (i.e
    bundle deals, greenwashing). We therefore hypothesized that private
    use of a certain type of car better gives insights on population
    view.
-   The match our swiss data set (new registration per year), we
    computed the difference of total cars registered in France per
    years. Having only the data between 2011 and 2022, we have "lost"
    the insights for 2011. Indeed, when creating the deltas (difference)
    columns, 2011 deltas could not be computed (no data for 2010), we
    therefore decided to delete that year from our data

```{r}
# Only taking the private cars from this data and transforming the data
df_v_fr <- france_v[25:37, ] %>%
  t() %>%
  as_tibble(.name_repair = "minimal") %>%
  setNames(.[1, ]) %>%
  slice(-1) %>%
  mutate(Year = 2011:2022) %>%
  select(-c("Particulier", "Gaz", "Gaz HNR", "Gaz HR", "Hydrogène et autre ZE", "Inconnu")) %>%
  mutate(across(-Year, ~ floor(as.numeric(.)))) %>%
  mutate(
    Conventional_Hybrid = as.numeric(`Diesel HNR`) + as.numeric(`Essence HNR`),
    Plug_in_Hybrid = as.numeric(`Diesel HR`) + as.numeric(`Essence HR`),
    across(c(Diesel, Essence, Conventional_Hybrid, Plug_in_Hybrid, Electrique), as.numeric),
    Diesel_delta = Diesel - lag(Diesel),
    Essence_delta = Essence - lag(Essence),
    Conventional_Hybrid_delta = Conventional_Hybrid - lag(Conventional_Hybrid),
    Plug_in_Hybrid_delta = Plug_in_Hybrid - lag(Plug_in_Hybrid),
    Electrique_delta = Electrique - lag(Electrique)
  ) %>%
  filter(!is.na(Diesel_delta)) %>%
  select(Date = Year, Diesel, Diesel_delta, Essence, Essence_delta, Conventional_Hybrid, Conventional_Hybrid_delta, Plug_in_Hybrid, Plug_in_Hybrid_delta, Electrique, Electrique_delta) %>%
  mutate(Date = as.Date(paste(Date, "-01-01", sep = ""), format = "%Y-%m-%d"))

# Display cleaned data
reactable(head(df_v_fr, 100), sortable = TRUE, searchable = TRUE)
```

### 2.2.6 Availability of charging stations

This data set will be used to explore and analyze the effects of
charging station availability on EVs adoption.

However, two important points are to note.

1.  We were unable to find data before November 2020
2.  Charging station availability and EV in market are likely strongly
    reciprocally correlated.

Moreover, it is important to keep standardized dates and locations

We merges 'year' and 'month' columns to create a 'Date' column in the
format "YYYY-MM-01", subsequently reorganizing the dataframe to position
'Date' as the first column and removing the original 'year' and 'month'
columns.

```{r}
# Combine 'year' and 'month' columns to create a new 'Date' column
charging_station$Date <- as.Date(paste(charging_station$year, charging_station$month, "01", sep = "-"), format = "%Y-%m-%d")

# Rearrange columns with 'Date' as the first column and drop 'year' and 'month'
df_charging_station <- charging_station %>%
  select(Date, everything()) %>%
  select(-year, -month)

# Display cleaned data
reactable(df_charging_station,
          sortable = TRUE, 
          searchable = TRUE)

```

### 2.2.7 Availability of charging station in France and Switzerland

This data set is used to complement the prior charging station data set.

It has data going back to 2012. And data for both Switzerland and France

```{r}
# Only selecting necessary columns
charge_ch_fr <- charge_ch_fr %>%
  select(c("year", "region", "powertrain", "value"))

# Setting year as.Date
charge_ch_fr$year <- as.Date(
  paste(charge_ch_fr$year,"-01-01", sep = ""), format = "%Y-%m-%d")

df_charge_number_CH <- charge_ch_fr %>%
  filter(region == "Switzerland")

df_charge_number_FR <- charge_ch_fr %>%
  filter(region == "France")
```

### 2.2.8 Political strength per canton

This data set will be used to explore and analyze the effects of
political convictions on EVs adoption (per Canton).

The 2 main difficulties with this data set were the following: 1. Create
a process (loop) general enough to clean all the Cantons at the same
time, but specific enough for it to work 2. The Swiss political parties'
names have evolved quite a bit over the years.

To use this data effectively in our analysis. We will group them in 5
categories.

The 5 categories respond to the following question: "What is the
political party's stance on sustainability / ecological measures?" 1.
Against 2. Slightly Against 3. Neutral 4. Slightly in Favour 5. In
Favour

We assigned each political parties in one of those categories based on
their program.

```{r}
# We import each different sheets (one per canton) into a data set
political_data_sheets <- lapply(setdiff(excel_sheets("../data/political_data.xlsx"), "Contenu"), 
                                function(sheet) {
                                  p_data <- suppressMessages(read_excel("../data/political_data.xlsx", sheet = sheet))
                                  return(p_data)
                                })

sheet_names <- setdiff(political_data_sheets_prep, "Contenu")

named_data_list <- setNames(political_data_sheets, sheet_names)

# Now to the cleaning part
for (i in seq_along(named_data_list)) {
  # setting one dataset we work on
  current_dataset <- named_data_list[[i]]
  
  # where is "taux de participation"
  index_to_keep <- which(current_dataset[[1]] == "Taux de participation")[1]
  
  # keep only rows until "taux de participation" and delete the first one "force des partis"
  named_data_list[[i]] <- current_dataset[2:index_to_keep-2, ]
  
  # remove columns 2 and 3 (they are all NAs)
  named_data_list[[i]] <- named_data_list[[i]][ ,-c(2,3)]
  
  # transposing the data sets to have years in a single columns
  transposed_data <- t(named_data_list[[i]])
  named_data_list[[i]] <- as_tibble(transposed_data[-1, ])
  
  # set column names and change date as.Date
  colnames(named_data_list[[i]]) <- transposed_data[1, ]
  
  named_data_list[[i]][[2]] <- as.Date(
  paste(named_data_list[[i]][[2]], "-01-01", sep = ""), format = "%Y-%m-%d")
  
  # find the columns that are only NAs and remove them
  named_data_list[[i]] <- named_data_list[[i]][, colSums(!is.na(named_data_list[[i]])) > 0, drop = FALSE]
  
  # Removing all non-numeric values
  named_data_list[[i]][, -1] <- apply(named_data_list[[i]][, -1], 2, function(x) as.numeric(gsub("[^0-9.]", "", x)))
  
  # Setting the first column name as "Date"
  colnames(named_data_list[[i]])[1] <- "Date"
  
  # Removing the rows before 01.01.1999
  threshold_date <- as.Date("1999-01-01")
  named_data_list[[i]] <- named_data_list[[i]][named_data_list[[i]]$Date >= threshold_date, ]
}

# Creating a map for the political parties stance on sustainability
sustainability_mapping <- c(
  "Against" = c("MCG (MCR)","PBD",	"PBD 1",	"PBD 2",	"UDC"),
  "Slightly Against" = c("Lega","PDC",	"PDC 1",	"PDC 2",	"PLR",	"PLS",	"UDF"),
  "Neutral" = c("Adl",	"DS",	"PdL",	"POCH",	"PSL",	"PST",	"Rép.",	"Sol.","Separ.", "Autres"),
  "Slightly in Favour" = c("Il Centro", "Il Centro 1",	"Le Centre 1","Le Centre",	"Le Centre 2",	"PCS","PPD",	"PPD 1"),
  "In Favour" = c("AVF",	"AVF 1",	"PEV", "PS",	"PSA",	"PVL","VERDI",	"VERDI 2","VERT-E-S  ",	"VERT-E-S 2",	"VERT-E-S 3")
)

# Looping through the data sets the change the names of the parties by their stance
for (i in seq_along(named_data_list)){
  current_dataset <- named_data_list[[i]]
  
  for (party_name in names(current_dataset)[-1]) {
    stance <- sapply(sustainability_mapping, function(x) party_name %in% x)
    stance <- names(stance)[which(stance)]
    
    if (length(stance) > 0) {
      selected_columns <- intersect(c(party_name, stance), colnames(current_dataset))
      
      current_dataset[[stance]] <- rowSums(current_dataset[selected_columns], na.rm = TRUE)
      current_dataset[[party_name]] <- NULL
    }
  }
  named_data_list[[i]] <- current_dataset
}

# Creating my 5 columns
categories <- c("Against", "Slightly Against", "Neutral", "Slightly in Favour", "In Favour")

# Aggregating the information of the data sets into these 5 categories
for (i in seq_along(named_data_list)) {
  current_dataset <- named_data_list[[i]]
  
  # Extract the Date column
  result_dataset <- current_dataset[, "Date", drop = FALSE]
  
  # Loop through each category and aggregate values
  for (category in categories) {
    matching_columns <- grep(paste0("^", category, "\\d*$"), colnames(current_dataset), value = TRUE)
    result_dataset[[category]] <- rowSums(current_dataset[matching_columns], na.rm = TRUE)
  }
  
  named_data_list[[i]] <- result_dataset
}

# Storing the data sets into a list:
list_politic <- list()

for (i in seq_along(named_data_list)) {
  tibble_name <- paste0("politic_", sheet_names[i])
  list_politic[[tibble_name]] <- named_data_list[[i]]
}

# Correcting a NA in politic_AI
new_dates <- list_politic[["politic_VD"]]$Date
list_politic[["politic_AI"]]$Date <- new_dates

# Creating a data set per year for Switzerland
political_combined_data <- bind_rows(list_politic, .id = "Canton")
political_combined_data$Year <- as.integer(format(political_combined_data$Date, "%Y"))
political_combined_data <- political_combined_data[, -which(names(political_combined_data) == "Date")]

political_summarized_data <- political_combined_data %>%
  group_by(Year, Canton) %>%
  summarize(
    Against = sum(Against),
    `Slightly Against` = sum(`Slightly Against`),
    Neutral = sum(Neutral),
    `Slightly in Favour` = sum(`Slightly in Favour`),
    `In Favour` = sum(`In Favour`)
  )

yearly_political_datasets <- list()
unique_years <- unique(political_combined_data$Year)
for (year in unique_years) {
  year_political_dataset <- political_combined_data %>% filter(Year == year)
  yearly_political_datasets[[as.character(year)]] <- year_political_dataset
}

# now accessible via ' political_yearly_data$Year '
political_combined_data <- political_combined_data %>%
  mutate(
    Canton = sub("politic_", "", Canton),  # Remove 'politic_' prefix
    Year = ymd(paste(Year, "01", "01"))    # Convert Year to date type
  )

political_combined_data <- political_combined_data %>%
  mutate(
    KANTONSNUM = case_when(
      Canton == "ZH" ~ 1,
      Canton == "BE" ~ 2,
      Canton == "LU" ~ 3,
      Canton == "UR" ~ 4,
      Canton == "SZ" ~ 5,
      Canton == "OW" ~ 6,
      Canton == "NW" ~ 7,
      Canton == "GL" ~ 8,
      Canton == "ZG" ~ 9,
      Canton == "FR" ~ 10,
      Canton == "SO" ~ 11,
      Canton == "BS" ~ 12,
      Canton == "BL" ~ 13,
      Canton == "SH" ~ 14,
      Canton == "AR" ~ 15,
      Canton == "AI" ~ 16,
      Canton == "SG" ~ 17,
      Canton == "GR" ~ 18,
      Canton == "AG" ~ 19,
      Canton == "TG" ~ 20,
      Canton == "TI" ~ 21,
      Canton == "VD" ~ 22,
      Canton == "VS" ~ 23,
      Canton == "NE" ~ 24,
      Canton == "GE" ~ 25,
      Canton == "JU" ~ 26
    )
  )

# Display cleaned data
reactable(political_combined_data,
          sortable = TRUE, 
          searchable = TRUE)
str(political_combined_data)
```

### 2.2.9 Swiss Population

We chose to use the population data from the year 2022 to ensure the
most current and relevant demographic context, providing a contemporary
snapshot that aligns closely with the latest trends in electric vehicle
registrations.

Assuming the relevant data starts from row 5, canton names are in the
first column, and the population figures for 2022 are in the second
column.

```{r}
df_swisspop_2022 <- df_swisspop_2022 %>%
  slice(-1:-4) %>%  # Remove the first 4 rows
  select(Canton = 1, TotalPopulation = 2)  # Select only the canton names and population figures

# Remove rows with NAs in the Canton column
df_swisspop_2022 <- df_swisspop_2022 %>%
  filter(!is.na(Canton))

# Map Canton names to abbreviations
df_swisspop_2022 <- df_swisspop_2022 %>%
  mutate(CantonAbbreviation = case_when(
    Canton == "Zurich" ~ "ZH",
    Canton == "Bern" ~ "BE",
    Canton == "Lucerne" ~ "LU",
    Canton == "Uri" ~ "UR",
    Canton == "Schwyz" ~ "SZ",
    Canton == "Obwalden" ~ "OW",
    Canton == "Nidwalden" ~ "NW",
    Canton == "Glarus" ~ "GL",
    Canton == "Zug" ~ "ZG",
    Canton == "Fribourg" ~ "FR",
    Canton == "Solothurn" ~ "SO",
    Canton == "Basel-Stadt" ~ "BS",
    Canton == "Basel-Landschaft" ~ "BL",
    Canton == "Schaffhausen" ~ "SH",
    Canton == "Appenzell A. Rh." ~ "AR",
    Canton == "Appenzell I. Rh." ~ "AI",
    Canton == "St. Gallen" ~ "SG",
    Canton == "Graubünden" ~ "GR",
    Canton == "Aargau" ~ "AG",
    Canton == "Thurgau" ~ "TG",
    Canton == "Ticino" ~ "TI",
    Canton == "Vaud" ~ "VD",
    Canton == "Valais" ~ "VS",
    Canton == "Neuchâtel" ~ "NE",
    Canton == "Geneva" ~ "GE",
    Canton == "Jura" ~ "JU",
    TRUE ~ NA_character_  # For unrecognized cantons
  ))

# Map Canton names to KANTONSNUM
df_swisspop_2022 <- df_swisspop_2022 %>%
  mutate(KANTONSNUM = case_when(
    Canton == "Graubünden" ~ 18,
    Canton == "Bern" ~ 2,
    Canton == "Valais" ~ 23,
    Canton == "Vaud" ~ 22,
    Canton == "Ticino" ~ 21,
    Canton == "St. Gallen" ~ 17,
    Canton == "Zurich" ~ 1,
    Canton == "Fribourg" ~ 10,
    Canton == "Lucerne" ~ 3,
    Canton == "Aargau" ~ 19,
    Canton == "Uri" ~ 4,
    Canton == "Thurgau" ~ 20,
    Canton == "Schwyz" ~ 5,
    Canton == "Jura" ~ 26,
    Canton == "Neuchâtel" ~ 24,
    Canton == "Solothurn" ~ 11,
    Canton == "Glarus" ~ 8,
    Canton == "Basel-Landschaft" ~ 13,
    Canton == "Obwalden" ~ 6,
    Canton == "Nidwalden" ~ 7,
    Canton == "Geneva" ~ 25,
    Canton == "Schaffhausen" ~ 14,
    Canton == "Appenzell A. Rh." ~ 15,
    Canton == "Zug" ~ 9,
    Canton == "Appenzell I. Rh." ~ 16,
    Canton == "Basel-Stadt" ~ 12,
    TRUE ~ NA_integer_  # For unrecognized cantons
  ))


df_swisspop_2022$TotalPopulation <- as.integer(df_swisspop_2022$TotalPopulation)
# Filter out rows where CantonAbbreviation is NA
df_swisspop_2022 <- df_swisspop_2022 %>%
  filter(!is.na(CantonAbbreviation))

# Display cleaned data
reactable(df_swisspop_2022,
          sortable = TRUE, 
          searchable = TRUE)

```

